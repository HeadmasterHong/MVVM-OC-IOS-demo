# OC进阶

## 关于block

为了隐藏复杂的块类型 我们可以借助typedef关键字

定义一个接收BOOL和int参数并返回int值的block

```objective-c
typedef int(^blockName)(BOOL flag, int value);

blockName block = ^(){

​	//IMP

};
```

![image-20210817114346196](OC%E8%BF%9B%E9%98%B6.assets/image-20210817114346196.png)

### 事件回调的方式

1. delegate
2. block
3. NSNotificationCenter
4. KVO (Key-Value-Observer)
5. Target-Action

### 优先级排序

1. block   处理事件结果, 代码简洁美观, 基本的回调功能都有, 满足各种情况的回调需求.
2. delegate   如果出现需要返回值, 有过程性质的存在, 可以代替block.

以下回调方式在上面无法实现的情况下去使用

1. NSNotificationCenter   1和2都不能实现一对多, 在这种情况下去使用.
2. Target-Action   自己很少实现, 一般使用系统自带的.
3. KVO 慎用.

## 关于runtime

OC runtime窥探
Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。

OC是一门动态语言,不仅需要一个编译器,也需要一个运行时系统来动态地创建类和对象,进行消息的传递和转发,理解runtime机制可以帮我们理解这门语言,适当地时候还能进行扩展,从系统层面解决项目的中的一些设计或难点
高级编程语言想要成为可执行文件首先要编译为汇编语言再汇编成机器语言,但是OC不能直接编译为汇编,要先转写为纯C,从OC到C的过渡就是由runtime来实现的,OC进行面向对象的开发而C则是面向过程开发,在这期间就需要将面向对象的类转为面向过程的结构体

runtime的主要特性就是消息传递,如果消息在对象中找不到就进行转发
### 消息传递
举个例子 [obj foo]
编译器转成消息发送 runtime的流程是这样的

```
id returnValue = [someObject messageName:parameter];
编译器看到这条消息就会转化为
id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter);
```

- 首先系统找到消息的接收对象,然后通过对象的isa指针找到它所属的类对象
- 在它的类对象中查找method list是否有selector方法
- 	如果没有则通过类对象的superclass查找它的method list
- 找到对应的method 执行它的IMP
- 转发IMP的return 值

类对象 (objc_class)

OC中的类是由Class类型来表示的,它实际上是一个指向obj_class结构体的指针
```
typedef struct objc_class *Class
```
runtime.h 中对于obj_class结构体定义如下
```
struct objc_class{
Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                        OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

}
```
类对象就是一个结构体,结构体包含的数据成为metadata,并且它的第一个成员变量也是isa指针 这就说明了Class本身也是一个对象 我们称之为类对象 类对象在编译期用于创建实例对象 是单例
metadata 存储的都是如何创建一个实例的相关信息
类对象也具有isa指针 类对象的isa指针指向的是元类(metaclass) 元类中保存了创建类对象和类方法(+)的所需所有信息 因此对于一个NSString *str 他的结构应该如下图

![image-20210806121118326](OC%E8%BF%9B%E9%98%B6.assets/image-20210806121118326.png)

根据这个图我们可以看出类对象的isa指针指向了元类 它的super class指针指向了他的父类类对象 元类的superclass指向了类对象的父类的元类 元类的isa指针指向rootclass的元类 一般也就是NSObject的元类

> 元类(Meta Class)是一个类对象的类。 在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。 为了调用类方法，这个类的`isa`指针必须指向一个包含这些类方法的一个`objc_class`结构体。这就引出了`meta-class`的概念，元类中保存了创建类对象以及类方法所需的所有信息。 任何`NSObject`继承体系下的`meta-class`都使用`NSObject`的`meta-class`作为自己的所属类，而基类的`meta-class`的`isa`指针是指向它自己。


![image-20210806121506091](OC%E8%BF%9B%E9%98%B6.assets/image-20210806121506091.png)

实例对象

```
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
/// A pointer to an instance of a class.
typedef struct objc_object *id;
```
Method(objc_method)

```
typedef struct objc_method *Method;
struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp  
```
SEL(objc_selector)

```typedef struct objc_selector *SEL;```
objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:,selector是SEL的一个实例
> A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.

其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。

这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。
比如：
```
- (void)caculate(NSInteger)num;
- (void)caculate(CGFloat)num;
```
复制代码是会报错的。
我们只能通过命名来区别：
```
- (void)caculateWithInt(NSInteger)num;
- (void)caculateWithFloat(CGFloat)num;
```
复制代码在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。

IMP

```
/// A pointer to the function of a method implementation.  指向一个方法实现的指针
typedef id (*IMP)(id, SEL, ...); 
#endif
```
复制代码就是指向最终实现程序的内存地址的指针。
在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。

Category(objc_category)

Catrgory是一个指向分类的结构体的指针
```
struct category_t { 
    const char *name; 
    classref_t cls; 
    struct method_list_t *instanceMethods; 
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
};

```
>name：是指 class_name 而不是 category_name。
cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。
instanceMethods：category中所有给类添加的实例方法的列表。
classMethods：category中所有添加的类方法的列表。
protocols：category实现的所有协议的列表。
instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和o

从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。

### 消息转发

对象接收到无法解读的信息后 首先将调用其所属类的

+(BOOL) resolveInstanceMethod:(SEL)selector

此方法常用来实现@dynamic属性, 比如创建一个动态词典 可以往内部动态新增属性(故意不给它自动生成get/set 使用resolve自动生成)

如果上一步无法处理,那么对象将调用

-(id)forwardingTargetForSelector:(SEL)selector

若当前接受者能找到备援对象 则将其返回 否则返回nil

如果还是不行就启用完整的消息转发机制

![image-20210817113359349](OC%E8%BF%9B%E9%98%B6.assets/image-20210817113359349.png)

```objective-c
class_getInstanceMethod//得到类的实例方法
class_getClassMethod//得到类的类方法
```

在开发中有的时候需要获得系统的类，实例方法与类方法，通过自己重写此方法进行IMP指针替换，实现自定义的方法实现替换系统的方法实现

![image-20210823110711670](OC%E8%BF%9B%E9%98%B6.assets/image-20210823110711670.png)

### runtime的实际应用场景

#### 给分类添加属性

当我们给类添加分类属性的时候 只会给类进行属性的setget声明 并不会进行实现他们 所以编译器会警告我们要实现set方法 并且也不会生成一个带下划线的成员变量

![image-20210823110731614](OC%E8%BF%9B%E9%98%B6.assets/image-20210823110731614.png)

所以我们借助objc_getAssociatiedObject或set 实现分类的get set, 同时让类在内部也可以操作分类中定义的属性

#### 消息转发机制

#### 动态交换方法的实现

####手动实现多继承

创建一个继承自NSProxy的类(可以视为是轻量级的NSobject, 需要自行实现init方法)遵从A、B两个类的协议 但是因为没有实现所以此时调用会报错, 这时我们就要在init方法中调用-(void)registerMethodsWithTarget:(id)target将A、B类的方法以target的形式写入我们的_methodMap_中再借助消息转发机制, 先进行方法签名 然后消息转发 创建A、B的对象进行sel接收 这样就能找到方法的是实现了

## 关于Runloop

完全看不懂

## 关于GCD

![image-20210830172925827](OC%E8%BF%9B%E9%98%B6.assets/image-20210830172925827.png)

有种简单而高效的方法可以替代同步块或锁对象，那就是使用“串行同步队列”。将读取操作以及写入操作都安排在同一个队列里，即可保证数据同步。
 用法如下：

```objectivec
@property (nonatomic,strong) dispatch_queue_t syncQueue;

_syncQueue = dispatch_queue_create("com.effetiveobjectivec.syncQueue", NULL);

- (NSString *)someString {
    __block NSString *localSomeString;
    dispatch_sync(_syncQueue, ^{
        localSomeString = _someString;
    });
    return _someString;
}

- (void)setSomeString:(NSString *)someString {
    dispatch_sync(_syncQueue, ^{
        _someString = someString;
    });
}
```

此模式的思路是：把设置操作与获取操作都安排在序列化的队列里执行，这样的话，所有针对属性的访问操作就都同步了。
 *注：getter方法中，用一个临时变量来保存值，是因为在block中return的话，只是return到block中了，没有真正返回到对应的getter方法中，而__block是为了可以在block中改变改临时变量而用。*



## 关于KVO


	[person addObserver:self forKeyPath:@"name"     options:NSKeyValueObservingOptionNew |NSKeyValueObservingOptionOld context:NULL]; 
本质上是在runtime创建了一个NSKVONotifying_Person, 继承自Person类实现对Person类属性的监听.并且重写了setName:, didChangeValueForKey: 以及class方法, 这样在调用setName的时候, 去调用didChangeValueForKey并添加观察者的通知, 而我们 调用[person class]时返回的是Person, 说明在子类中也重写了class方法并返回Person.

---







## MVVM在IOS开发中的应用

![image-20210810145227516](OC%E8%BF%9B%E9%98%B6.assets/image-20210810145227516.png)

MVVM(Model- ViewModel- View)

### 动机

随着开发的进行,MVC无法解决view controller越来越庞大的问题

MVVM将MVC中view controller的表示逻辑、数据缓存、网络处理等抽出来单独封装成View Model(例如将一个NSdate转化成NSString这件事情),**使得VC变得轻量化且易于测试**

### 各层次职责

> 1. Model层是少不了的了，我们得有东西充当DTO(数据传输对象)，当然，用字典也是可以的，编程么，要灵活一些。Model层是比较薄的一层，如果学过Java的小伙伴的话，对JavaBean应该不陌生吧。
> 2. ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。
> 3. View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。

![image-20210810160630367](OC%E8%BF%9B%E9%98%B6.assets/image-20210810160630367.png)

View Model中不仅要封装表示逻辑,还可以封装数据缓存、封装网络处理等

## UIGestureRecognizer

知识点：
UIGestureRecognizer是一个定义基本手势的抽象类，具体什么手势，在以下子类中包含：
    1、拍击UITapGestureRecognizer (任意次数的拍击)  
    2、向里或向外捏UIPinchGestureRecognizer (用于缩放)  
    3、摇动或者拖拽UIPanGestureRecognizer (拖动)
    4、擦碰UISwipeGestureRecognizer (以任意方向)  
    5、旋转UIRotationGestureRecognizer (手指朝相反方向移动)  
    6、长按UILongPressGestureRecognizer (长按)
————————————————

## 一些杂七杂八

点语法,等于使用存取方法访问实例变量
perspn.lastName same as [person lastName]
直接访问实例变量
_firstName
在对象中尽量使用直接访问实例变量
init方法直接访问实例变量不然容易引起循环访问

###对象属性特质

原子性 如果没有声明nonatomic那属性就是atomic的
读写权限 readwrite/readonly
内存管理 仅影响 setter assign 只针对纯量类型的简单赋值操作
strong 保留新值 释放旧值 设置新值
weak 非拥有关系 既不保留也不释放 当属性所指的对象被摧毁时属性夜会被清空
copy 遵从NS copying协议的对象 与strong类似 但是它不会保留新值 而是copy新值 常用在防止NSString被改变
(getter=isOn) 设置存取方法名


```objective-c
//使用comparator block进行排序
//    self.listTeams = [self.listTeams sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2){
//        NSDictionary *d1 = obj1;
//        NSDictionary *d2 = obj2;
//        return [[d1 objectForKey:@"name"] compare:[d2 objectForKey:@"name"]];
//    }];
    
    //使用descriptor来排序，descriptor本身只是一个获取keypath的工具，他能根据keypath进行排序
//    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"name" ascending:YES];
//    NSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];
//    self.listTeams = [self.listTeams sortedArrayUsingDescriptors:sortDescriptors];
    
    //使用selector进行排序】
//    for (NSArray *listteam in _listTeams) {
//        [listteam sortedArrayUsingSelector:@selector(compare:)];
//    }
```

### 优雅编程

#### 尤达表达式

不要使用尤达表达式。尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是 “天空是不是蓝的” 或者 “这个男人是不是高个子的”

	if ([myValue isEqual:@42]) { ...
	//而不是
	if ([@42 isEqual:myVqlue]) { ...

当三元运算符的第二个参数（if 分支）返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧：

推荐:

result = object ? : [self createObject];
不推荐:

result = object ? object : [self createObject];

#### Enumerated Types 枚举类型
typedef NS_ENUM(NSUInteger, ZOCMachineState) {
    ZOCMachineStateNone,
    ZOCMachineStateIdle,
    ZOCMachineStateRunning,
    ZOCMachineStatePaused
};

#### 方法名标准
推荐
	- (void)setExampleText:(NSString *)text image:(UIImage *)image;
	- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
	- (id)viewWithTag:(NSInteger)tag;
	- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
不推荐
	- (void)setT:(NSString *)text i:(UIImage *)image;
	- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
	- (id)taggedView:(NSInteger)tag;
	- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
	- (instancetype)initWith:(int)width and:(int)height;  // Never do this.

上左下右UIEdgeInset 内偏移量

以下代码实现有错吗？如果有，请指出并修改。
   代码：
   ```objective-c
   typedef void (^MyBlock)(void);
   @interface MyObject : NSObject
   {
     MyBlock _myBlock;
   }
   @end
   
   @implementtation MyObject
   \- (id)init
   {
     self = [super init];
     if(self) {
       _myBlock = ^{NSLog(@“self = %@”, self);};

​     }
​     return self;
   }
   @end
   ```
答：   有循环引用的问题，调用init初始化MyObject对象后，MyObject对象永远释放不了，导致内存泄露。解决办法是将 _myBlock = ^{NSLog(@“self = %@”, self);}; 改为 id __weak myObject = self; _myBlock = ^{NSLog(@“self = %@”, myObject);};

>  谈一下对iOS App的架构理解。应该怎么处理UI逻辑和数据业务逻辑关系。有没有什么办法可以实现一些通用架构能快速应用于所有应用类iOS项目的研发中已提开发效率、以及提高项目的稳定、可扩展、易维护性。
> 答：   1、UI逻辑＋业务逻辑＝App。UI逻辑与业务逻辑要尽量独立。
>    2、UI组建化、业务逻辑组件化。
>    3、建立独立的工具类，创建单列管理全局变量，完善的错误处理，独立的语言包，独立的枚举、宏定义处理等等。

bounds和frame的区别

- frame是参考父view的坐标系来设置自己左上角的位置。
- 设置bounds可以修改自己坐标系的原点位置，进而影响到其“子view”的显示位置。

> scrollview滚动的原理就是不断更改自身的bounds 从而让自己的contentView的frame不断改变, 实现滚动的效果 可以使用

```objective-c
[UIView animateWithDuration:3.0 animations:^{
    [view1 setBounds:CGRectMake(0, 1000, 200, 100)];
}];
```

感受一下

一些关键字

inline

>内联函数是指用 inline 关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时类似于宏替换，使用函数体替换调用处的函数名。一般在代码中用 inline 修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。



extern

> 它的作用**是声明外部全局变量**。这里需要特别注意extern只能声明，不能用于实现。

_Nullable _Nonnull

```objective-c
@interface **DataManager** : NSObject

\- (NSString * _Nullable) **loadDataByID**: (NSString * _Nonnull) identity;

@end
```

在每个类型的后面， 加入了 _Nonnull 标记。 这样在编译的时候就不会出现警告了。 那么它们的作用是什么呢？ 从名字上看， 大家应该也能猜出一二。 这个标记就是用来标注某个参数是否可以为空。 以我们上面这个例子来说， 就是它接受的 identiiy 参数不能为空， 但返回的 NSString 对象可以为空。 并且它还提供了编译器检查功能， 如果我们对上面那个方法传入 nil， 编译器是会检测出来，并给出警告的：

####podfile第三方

```bash
这个路径说明第三方来自不是CocoaPods
source 'git@github.com:aliyun/aliyun-specs.git'  
```

------



```bash
如果出现上面的那一句必须加上该句，因为其它的第三方是来自CocoaPods
source 'https://github.com/CocoaPods/Specs.git' 
```



### LightArt

[head.templates](http://lightart.dev.vipshop.com/#/协议简介?id=headtemplates)

head.templates定义的模板数据，目前只包含body一个节点，所有模板数据都在body节点里面，详情看考[模板语法](http://lightart.dev.vipshop.com/#/模板语法)

[head.datas](http://lightart.dev.vipshop.com/#/协议简介?id=headdatas)

head.datas定义的是模板需要的数据，数据如何通过模板转换生成视图模型，请参考[模板语法](http://lightart.dev.vipshop.com/#/模板语法)

[head.actions](http://lightart.dev.vipshop.com/#/协议简介?id=headactions)

head.actions定义的是行为，请参考[行为](http://lightart.dev.vipshop.com/#/行为)

[head.events](http://lightart.dev.vipshop.com/#/协议简介?id=headevents)

head.events定义的是事件，请参考[事件](http://lightart.dev.vipshop.com/#/事件)

如果$lightart.body为空，则查看$lightart.head.templates.body和$lightart.head.datas.body是否存在，假如都存在， 则使用模板加数据生成LVM，然后进行渲染。

### 关于放大模式

[UIScreen mainScreen].bounds代表的是当前屏幕的边界 以点为单位

[UIScreen mainScreen].bounds代表的是物理屏幕的分辨率 也就是真实分辨率

[UIScreen mainScreen].currentMode代表的是当前的屏幕模式 封装了单点像素纵横比 屏幕的大小(以像素计算) size可以代表逻辑

![image-20210908104954457](/Users/ryan.hong/Library/Application Support/typora-user-images/image-20210908104954457.png)



